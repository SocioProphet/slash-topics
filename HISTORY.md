# Slash Topics for 2025

We’re calling them **slash topics** (not “slashtags”) and treating blekko as the fossil record: the bones are good, but the organism needs 2025 organs—provenance, governance, deterministic receipts, and commons-grade safety.

## Thesis

We are rebuilding the *idea* of blekko—not its brand or UI. The idea is simple and still correct: **a search/knowledge surface becomes trustworthy when “scope” is explicit, curated, and composable**.

Blekko did that with slash-based scoping: topical directories and built-in operators. Our 2025 design keeps the interface primitive (a leading slash) but upgrades everything around it: **governance, provenance, safety defaults, deterministic execution receipts, and interoperability with a global knowledge commons stack**.

## What we have (seed artifacts)

We already recovered a complete slash topic inventory from the archived blekko directory and normalized it into machine-usable files:

- `blekko_slashtags_2012-10-15.csv`
- `blekko_slashtags_2012-10-15.json`
- `blekko_slashtags_2012-10-15.md`

Those files form our **bootstrap taxonomy**: a versioned seed corpus we can sign, diff, fork, and mount into a protocol registry.

## Why this becomes “commons infrastructure”

If we only re-implement slash filters, we get a nostalgia project. Our real move is:

**Slash topics become governed public objects** with provenance, a curation lifecycle, policy-aware execution, and deterministic receipts.

That makes them interoperable with an auditable runtime (New Hope / TritRPC), and safe by default (membrane-enforced policies, explicit integrations, visible provenance).

## Defaults posture (enforceable)

- Safe by default (no porn; no exploitative content; no malware; no content farms)
- High-signal by default (reference/science/education/humanities/computers/government)
- Opt-in for commercial/noise-heavy verticals
- Explicit integrations only (no silent third-party calls)
- Provenance visible (who curated, when, what rules, what sources)

## Mapping to the New Hope hardening checklist

1) Canonicalization RFC: exact hashing/serialization rules and signing coverage  
2) Membrane decision model: standardized outputs + required audit fields  
3) Protocol registry bundling: versioned topic pack artifacts with content hashes  
4) Workflow harness: FA + replay checkpoints + deterministic execution receipts  
5) TritRPC fixtures: canonical frame fixtures for cross-language tests
